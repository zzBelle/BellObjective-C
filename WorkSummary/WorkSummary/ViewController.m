//
//  ViewController.m
//  WorkSummary
//
//  Created by 十月 on 2017/8/7.
//  Copyright © 2017年 October. All rights reserved.
//

#import "ViewController.h"

@interface ViewController ()

@end

@implementation ViewController
/*
  内存管理，堆与栈的区别 哪些在堆上，哪些在栈上
 
 内存管理的范围：
    1.只有OC对象需要进行内存管理
    2.非OC对象类型比如基本数据类型不需要进行内存管理
 
 只有OC对象才需要进行内存管理的本质原因？
 因为Objective-C 的对象在内存中是以堆的方式分配内存空间的，并且堆内存是由你释放的，就是release。
 OC对象存放于堆里边（堆内存要程序猿手动释放回收）
 非OC对象一般在栈里边（栈内存会被系统自动回收）
 堆里的内存是动态分配的，所以也就需要手动添加内存回收内存
 
 
 按分配方式
    堆是动态分配和回收内存的，没有静态分配的堆(堆对象是采用链表进行管理的，操作系统有一个记录空闲内存地址的链表，当程序收到申请时，会遍历链表，寻找第一个申请的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序)
 
    栈是有两种分配方式：静态分配和动态分配
        静态分配 是系统编译完成的，比如局部变量的分配
        动态分配是alloc函数进行分配的，但是栈的动态分配和堆是不同的，它的动态分配也是由系统编译器进行释放，不需要手动管理。
 
 堆与栈的区别：
 栈是先进后出（LIFO） 堆是先进先出（FIFO)
 
 
 
 哪些在堆上，哪些在栈上
 我们自己申请的变量信息一般是在堆上
 程序运行时调用的函数一般是在栈上
 
 特殊的情况
 block block是在栈上的但是在copy后就到堆上了
 */
/*
 Category与Extension区别，与继承的区别，各自的适用场景
 
一、 Category 分类
 分类就是对一个类的功能进行扩展，让这个类能够适应不同情况的需求，在一般的实际开发中，都会对系统的一些常用类进行扩展，简单来说句式一种为现有的类添加新方法的方式。
 
 利用Objective-C 的动态运行时分配机制，Category提供了一种比继承更为简洁的方法对类进行扩展，无需创建对象类的子类就能实现现有的类添加新方法，可以为任何已经存在的类添加方法，包括哪些没有源码的类。如系统的框架类等
 
 Category的作用：
 1.可以将类的实现分散到多个不同的文件或者不同的框架中，方便代码的管理。也可以对框架提供类的扩展。（没有源码，不能修改）
 2.创建对私有方法的向前引用：如果其他类中的方法未实现，在你访问其他类的私有方法时编译器报错这时使用类别，在类别中声明这些方法（不必提供方法的实现），编译器就不会在产生警告。
 3.向对象添加非正式的协议：创建一个NSObject的类别称为"创建一个非正式协议"，因为可以作为任何类的委托对象使用。
 
 局限性：
    1.分类只能增加方法，不能增加成员变量，但是可以通过运行时来给分类添加属性，那么成员变量和属性有什么区别？
    成员变量和属性的区别:
    声明一个属性： @property (nonatomic, strong) NSString *myString;
 
    声明一个成员变量:（实例变量）
    @interface MyViewController:UIViewController
    {
    NSString *_myString;
    }
    @end
    我们声明了一个属性，因为现在的编译器已经是LLVM了，所以不再需要为属性声明实例变量了。如 LLVM 发现一个没有匹配实例变量的属性， 为你生成以下划线开头的实例变量 _myString，不需你自己动手再去写实例变量。而且不需要在.m文件中写@synthesize myString; 也会自动为你生成setter和getter方法。 那么在.m 文件中可以直接的使用_myString实例变量，也可以通过属性self.myString 两者是一样的。只不过后者是通过调用_myString的setter和getter方法。
 
    @synthesize还有一个作用，可以指定与属性对应的实例变量，例如@synthesize myString = XXXX; 那么self.myString 其实就是操作的实例变量XXXX，而不是_myString;
 
    分类中用@property 定义变量，只会生成getter，setter方法的声明，不能生成方法实现和带下划线的成员变量。 可以通过运行时建立关联引用来解决。
 
 2.如果分类和原来类出现同名的方法，优先调用分类中的方法，原来类中的方法会被忽略，方法调用的优先级（从高到低）分类（最后参与编译分类优先），只要有分类就优先调用分类，不考虑与主类的编译顺序
 
 3.利用运行时来为分类添加属性
    1 引入运行时头文件
    #import<objc/runtime.h>
    2 在匿名分类或者头文件中添加属性。区别是：匿名分类中添加的是私有属性，只在本类中可以使用，类的实例中不可以使用。头文件中添加的类的实例中也可以使用。

    //分类的头文件 可以参考 NSString+CategoryName.h 和 NSString+CategoryName.m
    @interface ClassName (CategoryName)
    //我要添加一个实例也可以访问的变量所以就写在这里了
    @property (nonatomic, strong) NSString *str;
    @end
 
    //匿名分类
    @interface ClassName ()
 
    @end

 */

/*
 二、继承
 多个类具有相同的实例变量和方法时，考虑用继承。即子类可以继承父类相同的特性。如animal只有年龄和体重这两个属性，dog也具有年龄和体重这两个属性，dog可以继承animal的这两个属性。即为继承。
 
 和Category的区别：
 1.类别是对方法的扩展，不能添加成员变量。继承可以在原来的父类的成员变量的基础上，添加新的成员变量。
 2.类别只能添加新的方法，不能修改和删除原来的方法，继承而已增加、修改和删除原来的方法。
 3.类别不提倡对原来的方法重载。继承可以通过使用super对原来的方法进行重载。
 4.类别可以被继承，如果一个父类中定义了类别，那么子类中也会继承次类别。
 共同点：都是给一个类进行扩展

 */
/*
 三、类扩展 Extension
 Extension 是Category的一个特列
 作用：为一个类添加私有的方法，属性或者成员变量，也就是说只能在本文件中被使用，其名字为匿名（为空），
 并且新添加的方法一定要实现。（Category没有这个限制）
 
 第一种方法
 通过延展来实现方法的私有，延展的头文件独立。这种方法不能实现真正的方法私有，当在别的文件中引入延展的头文件，那么在这个文件中定义的类的对象就可以直接调用在延展中定义的所谓的私有方法。
 
 第二种方法
 延展没有独立的头文件，在类的实现文件.m中声明和实现延展，这种方法可以很好的实现方法的私有，因为OC中是不能引入.m文件的
 
 第三个实现方法
 私有方式是在.m文件中的@implementation中直接实现在@interface中没有声明的方法，这样也可以很好的实现方法的私有，常用这种方式。
 */
/*
    1.形式上看，extension是匿名的category，有人将extension叫做匿名分类，但是其实两者差别很大的。
 extension 类扩展
    1>在编译器决议，是类的一部分，在编译器和头文件的@interface和实现文件里的@implement一起形成了一个完整的类。
    2>伴随着类的产生而产生，也随着类的消失而消失。
    3>extension一般用来隐藏类的私有消息，你必须有一个类的源码才能添加一个类的extension，所以对系统一些类，如NSString，就无法添加类扩展
 
 category 分类
    1>是运行期决议的
    2>类扩展可以添加实例变量，分类不能添加是例变量
 原因：因为在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局，这对变异性语言是灾难性的。
 
 
 */
- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
}


- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}


@end
